name: Build → Push to ECR → Deploy via SSM (no instance role)

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Image tag to build & deploy (format: vMAJOR.MINOR.PATCH, e.g., v1.0.0)'
        required: true
        default: 'v1.0.0'

env:
  ECR_REGISTRY: "909688465000.dkr.ecr.ap-south-1.amazonaws.com"
  ECR_REPOSITORY: "ust/training"
  AWS_REGION: "ap-south-1"
  EC2_PUBLIC_DNS: "ec2-15-207-98-178.ap-south-1.compute.amazonaws.com"
  INSTANCE_PRIVATE_IP: "172.31.2.162"
  HEALTHCHECK_PATH: "/"
  HEALTHCHECK_PORT: "3000"
  HEALTHCHECK_RETRIES: "12"
  HEALTHCHECK_SLEEP_SECONDS: "5"

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Determine tag
        id: tag
        run: |
          set -euo pipefail
          if [ "${GITHUB_EVENT_NAME:-}" = "push" ] && echo "${GITHUB_REF:-}" | grep -q '^refs/tags/'; then
            TAG="${GITHUB_REF#refs/tags/}"
          else
            TAG="${{ github.event.inputs.tag }}"
          fi
          if ! echo "$TAG" | grep -qE '^v[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "::error::Invalid tag: $TAG. Expected vMAJOR.MINOR.PATCH"
            exit 1
          fi
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Configure AWS credentials for runner
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure ECR repository exists
        run: |
          aws ecr describe-repositories --repository-names "${ECR_REPOSITORY}" >/dev/null 2>&1 || \
            aws ecr create-repository --repository-name "${ECR_REPOSITORY}"
        env: { ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }} }

      - name: Login Docker to ECR (runner) and get ECR login token
        id: ecr_login
        run: |
          set -euo pipefail
          echo "Getting ECR login password (this is short-lived)..."
          LOGIN_PW=$(aws ecr get-login-password --region "${AWS_REGION}")
          # login on runner so push works
          echo "$LOGIN_PW" | docker login --username AWS --password-stdin "${ECR_REGISTRY}"
          # export trimmed token as output (careful: this will be in workflow logs if printed; we won't print)
          echo "login_pw<<EOF" >> "$GITHUB_OUTPUT"
          echo "$LOGIN_PW" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build & push image to ECR
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ steps.tag.outputs.tag }}

      - name: Resolve instance id by public DNS
        id: find_instance
        run: |
          set -euo pipefail
          PUBLIC_DNS="${{ env.EC2_PUBLIC_DNS }}"
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[?PublicDnsName=='${PUBLIC_DNS}'].InstanceId | [0]" \
            --output text --region "${AWS_REGION}")
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "::error::Could not find running instance with PublicDnsName=${PUBLIC_DNS}"
            exit 1
          fi
          echo "instance_id=$INSTANCE_ID" >> "$GITHUB_OUTPUT"
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Deploy via SSM (pass ECR token to instance)
        id: ssm_deploy
        run: |
          set -euxo pipefail

          INSTANCE_ID="${{ steps.find_instance.outputs.instance_id }}"
          TAG="${{ steps.tag.outputs.tag }}"
          IMAGE="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${TAG}"
          AWS_REGION="${{ env.AWS_REGION }}"

          # get the login password from the previous step output (multiline handling)
          LOGIN_PW="$(printf '%s\n' "${{ steps.ecr_login.outputs.login_pw }}")"

          echo "Sending SSM command to instance $INSTANCE_ID to deploy image $IMAGE"

          # Build remote script (the $LOGIN_PW will be expanded here on the runner)
          read -r -d '' REMOTE <<'EOF'
#!/bin/bash
set -euxo pipefail

IMAGE="$1"
LOGIN_PW="$2"
AWS_REGION="$3"
ECR_REGISTRY="$4"
CONTAINER_NAME="ust-training-app"

echo "Remote: logging into ECR (using provided token)"
echo "${LOGIN_PW}" | docker login --username AWS --password-stdin "${ECR_REGISTRY}"

echo "Remote: pulling ${IMAGE}"
docker pull "${IMAGE}"

if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
  echo "Remote: stopping & removing ${CONTAINER_NAME}"
  docker rm -f "${CONTAINER_NAME}" || true
fi

echo "Remote: running ${CONTAINER_NAME}"
docker run -d --name "${CONTAINER_NAME}" --restart unless-stopped -p 3000:3000 "${IMAGE}"

echo "Remote: done"
EOF

          # send the command, passing IMAGE, LOGIN_PW, AWS_REGION, ECR_REGISTRY as args
          CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy ${IMAGE}" \
            --parameters commands=["/bin/bash -c 'bash -s \"${IMAGE}\" \"${LOGIN_PW}\" \"${AWS_REGION}\" \"${{ env.ECR_REGISTRY }}\"'"],workingDirectory=["/tmp"] \
            --query "Command.CommandId" --output text --region "${AWS_REGION}")

          echo "SSM CommandId: $CMD_ID"

          # wait for completion
          for i in $(seq 1 60); do
            STATUS=$(aws ssm list-command-invocations --command-id "$CMD_ID" --details --query "CommandInvocations[0].Status" --output text --region "${AWS_REGION}" ) || STATUS=""
            echo "Invocation status: $STATUS"
            if [ "$STATUS" = "Success" ] || [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              break
            fi
            sleep 5
          done

          echo "---- SSM STDOUT ----"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query "StandardOutputContent" --output text --region "${AWS_REGION}" || true
          echo "---- SSM STDERR ----"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query "StandardErrorContent" --output text --region "${AWS_REGION}" || true

          if [ "$STATUS" != "Success" ]; then
            echo "::error::SSM command ended with status: $STATUS"
            exit 1
          fi
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}

      - name: Health check (public + private)
        id: health
        run: |
          set -euo pipefail
          PUBLIC_URL="http://${{ env.EC2_PUBLIC_DNS }}:${{ env.HEALTHCHECK_PORT }}${{ env.HEALTHCHECK_PATH }}"
          PRIVATE_URL="http://${{ env.INSTANCE_PRIVATE_IP }}:${{ env.HEALTHCHECK_PORT }}${{ env.HEALTHCHECK_PATH }}"
          RETRIES=${{ env.HEALTHCHECK_RETRIES }}
          SLEEP=${{ env.HEALTHCHECK_SLEEP_SECONDS }}

          do_sleep() {
            if command -v sleep >/dev/null 2>&1; then sleep "$1"; else python3 -c "import time; time.sleep($1)"; fi
          }

          http_check() {
            url="$1"
            if command -v curl >/dev/null 2>&1; then
              curl -s -o /dev/null -w "%{http_code}" -m 5 "$url" || echo "000"
            else
              python3 - <<PY
import sys,urllib.request
url=sys.argv[1]
try:
  r=urllib.request.urlopen(url, timeout=5)
  print(r.getcode())
except Exception:
  print("000")
PY
            fi
          }

          echo "Public URL: $PUBLIC_URL"
          echo "Private URL: $PRIVATE_URL"

          public_ok=false
          for i in $(seq 1 $RETRIES); do
            status=$(http_check "$PUBLIC_URL" 2>/dev/null || echo "000")
            echo "public attempt $i -> $status"
            if [ "$status" = "200" ]; then public_ok=true; break; fi
            do_sleep $SLEEP
          done

          private_ok=false
          for i in $(seq 1 $RETRIES); do
            status=$(http_check "$PRIVATE_URL" 2>/dev/null || echo "000")
            echo "private attempt $i -> $status"
            if [ "$status" = "200" ]; then private_ok=true; break; fi
            do_sleep $SLEEP
          done

          echo "Summary: public=$public_ok private=$private_ok"
          if [ "$public_ok" = "true" ] || [ "$private_ok" = "true" ]; then
            echo "Health check OK"
            exit 0
          else
            echo "::error::Health check failed"
            exit 1
          fi
